<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>WIP - small to large</title>
    <link rel="self" type="application/atom+xml" href="https://leoriether.github.io/tags/small-to-large/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://leoriether.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2021-06-05T00:00:00+00:00</updated>
    <id>https://leoriether.github.io/tags/small-to-large/atom.xml</id>
    <entry xml:lang="en">
        <title>Intuition Behind the Small to Large Algorithm</title>
        <published>2021-06-05T00:00:00+00:00</published>
        <updated>2021-06-05T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://leoriether.github.io/posts/small-to-large/"/>
        <id>https://leoriether.github.io/posts/small-to-large/</id>
        
        <content type="html" xml:base="https://leoriether.github.io/posts/small-to-large/">&lt;h1 id=&quot;the-problem&quot;&gt;The Problem&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-problem&quot; aria-label=&quot;Anchor link for: the-problem&quot;&gt;#&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;p&gt;What if we want to build some data structure for every node in a tree, to solve
a certain problem, but to build that structure for node &lt;code&gt;u&lt;&#x2F;code&gt; we need to trasverse
the entire subtree of &lt;code&gt;u&lt;&#x2F;code&gt;, thus making the algorithm at least &lt;code&gt;O(N²)&lt;&#x2F;code&gt;, which is
not fast enough in some cases, could we do better?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example&quot;&gt;Example&lt;a class=&quot;zola-anchor&quot; href=&quot;#example&quot; aria-label=&quot;Anchor link for: example&quot;&gt;#&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You&#x27;re given a tree with &lt;code&gt;N&lt;&#x2F;code&gt; nodes ($N \le 10^5$), in which every node has a
value between $1$ and $10^6$. Answer &lt;code&gt;Q&lt;&#x2F;code&gt; queries ($Q \le 10^5$) that give you an
integer &lt;code&gt;k&lt;&#x2F;code&gt;, a node &lt;code&gt;u&lt;&#x2F;code&gt;, and ask you how many nodes in the subtree of &lt;code&gt;u&lt;&#x2F;code&gt; have
value equal to &lt;code&gt;k&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;8211902&#x2F;120910700-4bbc0600-c657-11eb-9df6-493f39562b62.png&quot; alt=&quot;t0&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If the constraints were smaller, for example $N \le 10^3$ and $Q \le 10^3$, it
would be possible to solve this problem by running a DFS starting at the node
given in the query. The DFS would create a data structure -- a frequency array
-- that allows us to lookup the answer easily. That&#x27;s not the simplest way to
solve this problem in particular, but it&#x27;s one that exemplifies the kind of
reasoning behind Small to Large, so bear with me.&lt;&#x2F;p&gt;
&lt;p&gt;With the bigger constraints, however, this algorithm isn&#x27;t fast enough because
we go through &lt;code&gt;O(N)&lt;&#x2F;code&gt; nodes each query, in the worst case.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;8211902&#x2F;120910175-01d12100-c653-11eb-86d8-dd77f574beae.png&quot; alt=&quot;t1&quot; &#x2F;&gt; &lt;&#x2F;p&gt;
&lt;p&gt;In some cases, however, we don&#x27;t have &lt;code&gt;O(NQ)&lt;&#x2F;code&gt; complexity. Imagine, first, that
we cache the frequency tables for nodes we&#x27;ve already processed. Then, what&#x27;s
the time complexity &lt;strong&gt;if the tree is balanced and binary&lt;&#x2F;strong&gt;?. Then, we would take
&lt;code&gt;N&lt;&#x2F;code&gt; time in the root node, &lt;code&gt;N&#x2F;2 + N&#x2F;2&lt;&#x2F;code&gt; time in the children of the root, &lt;code&gt;N&#x2F;4 + N&#x2F;4 + N&#x2F;4 + N&#x2F;4&lt;&#x2F;code&gt; in the children of the children of the root node, ... It&#x27;s
exactly like a mergesort: &lt;code&gt;O(N log N)&lt;&#x2F;code&gt;!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;8211902&#x2F;120910404-1ca49500-c655-11eb-92db-914a99183ef1.png&quot; alt=&quot;t2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;optimization-ideas&quot;&gt;Optimization Ideas&lt;a class=&quot;zola-anchor&quot; href=&quot;#optimization-ideas&quot; aria-label=&quot;Anchor link for: optimization-ideas&quot;&gt;#&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;What are some heuristics we could use to optimize the naive algorithm?&lt;&#x2F;p&gt;
&lt;h4 id=&quot;1-offline&quot;&gt;1. Offline&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-offline&quot; aria-label=&quot;Anchor link for: 1-offline&quot;&gt;#&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;p&gt;Instead of answering queries in the order they are given, we could compute them
in whichever order is most convenient to us, store the answers, then print them
in the right order.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;2-reuse-the-result-from-some-dfss&quot;&gt;2. Reuse the result from some DFSs&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-reuse-the-result-from-some-dfss&quot; aria-label=&quot;Anchor link for: 2-reuse-the-result-from-some-dfss&quot;&gt;#&lt;&#x2F;a&gt;
&lt;&#x2F;h4&gt;
&lt;p&gt;Let&#x27;s go back to the example tree that gave us &lt;code&gt;O(N²)&lt;&#x2F;code&gt; runtime. Did we really
need to run a DFS for every single node? The answer is no! We could, in that
particular case, reuse the frequency table generated in the child and update it
in &lt;code&gt;O(1)&lt;&#x2F;code&gt; to get the frequency for the parent, like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#191919;color:#f8f8f2;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;font-style:italic;color:#fbdfb5;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; frequency[MAX_K];
&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#fbdfb5;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8cdaff;&quot;&gt;dfs&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#fbdfb5;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;font-style:italic;color:#fc9354;&quot;&gt;u&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e9fdac;&quot;&gt;dfs&lt;&#x2F;span&gt;&lt;span&gt;(child[u]);
&lt;&#x2F;span&gt;&lt;span&gt;    frequency[value[u]]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ff5e5e;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6d6d6d;&quot;&gt;&#x2F;&#x2F; we now have a valid frequency table for `u`
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But is this always possible? What should we do in this case?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;8211902&#x2F;120910622-bb7dc100-c656-11eb-909a-4db0bc26e36b.png&quot; alt=&quot;t3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Answer: yes, but there&#x27;s a catch. First, we should run DFS for node 7 and clear
the frequency table. Then, we carry on with the DFS of the other nodes in the
optimized way, reusing tables from the child.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;small-to-large&quot;&gt;Small to Large&lt;a class=&quot;zola-anchor&quot; href=&quot;#small-to-large&quot; aria-label=&quot;Anchor link for: small-to-large&quot;&gt;#&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;p&gt;The optimizations shown are sufficient to make an &lt;code&gt;O(N log N)&lt;&#x2F;code&gt; algorithm for the
problem! The general idea is that a DFS call will&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Compute the data structures for each &amp;quot;small&amp;quot; child (small in the sense that
they have less nodes in their subtrees, like 7 only had 1 node in its
subtree);&lt;&#x2F;li&gt;
&lt;li&gt;Clear the data structures in each of their DFS calls (assuming the DFS
modifies one global data structure);&lt;&#x2F;li&gt;
&lt;li&gt;Compute the data structure for the &amp;quot;big&amp;quot; child (the one with the biggest
subtree), but instead of clearing it, reuse it to compute the parent&#x27;s
answer.&lt;&#x2F;li&gt;
&lt;li&gt;Iterate over the subtrees of the small children and the parent node, updating
the data structure accordingly.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The rest of this blog is still WIP ;)&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
